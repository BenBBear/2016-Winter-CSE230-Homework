<h1 id="assertions">Assertions</h1>
<div class="hidden">
<pre><span class=hs-linenum>6: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Assert</span> <span class='hs-layout'>(</span><span class='hs-varid'>die</span><span class='hs-layout'>,</span> <span class='hs-varid'>fixme</span><span class='hs-layout'>,</span> <span class='hs-varid'>lAssert</span><span class='hs-layout'>,</span> <span class='hs-varid'>divide</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>7: </span>
<span class=hs-linenum>8: </span><span class='hs-definition'>divide</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Double</span>
<span class=hs-linenum>9: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>10: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
</pre>
</div>
<p>As a warm up, first lets recall how we can specify and verify <em>assertions</em> with Refinement Types.</p>
<h2 id="dead-code">Dead Code</h2>
<p>Recall from lecture, that we can define a function that should <em>never</em> be called.</p>
<pre><span class=hs-linenum>24: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>die</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>String</span> <span class='hs-keyword'>| false}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>25: </span><a class=annot href="#"><span class=annottext>lq_tmp_x_362:{VV : [Char] | false} -&gt; t</span><span class='hs-definition'>die</span></a> <a class=annot href="#"><span class=annottext>{VV : [Char] | false}</span><span class='hs-varid'>str</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x_410 : [{lq_tmp_x_407 : Char^"lq_tmp_x_387" | $k__386[VV#385:=lq_tmp_x_407][lq_tmp_x_383:=lq_anf__d10L][lq_tmp_x_384:=str#aXo][lq_tmp_x_388:=lq_tmp_x_407][lq_tmp_x_380:=lq_tmp_x_410]}] | lq_tmp_x_410 == lq_anf__d10M}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x_392 : [Char] | lq_tmp_x_392 == lq_anf__d10L}</span><span class='hs-str'>"Oops, I died!"</span></a> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x_396 : [Char] | lq_tmp_x_396 == str#aXo}</span><span class='hs-varid'>str</span></a><span class='hs-layout'>)</span>
</pre>
<p>We can use this function in all those places where we need to handle some case that we can know (and want to prove) will never happen at run-time.</p>
<p>Here's a variant of <code>die</code> that we will use for those places where <em>you</em> need to fill in code:</p>
<pre><span class=hs-linenum>33: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fixme</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>String</span> <span class='hs-keyword'>| false}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>34: </span><a class=annot href="#"><span class=annottext>lq_tmp_x_312:{VV : [Char] | false} -&gt; t</span><span class='hs-definition'>fixme</span></a> <a class=annot href="#"><span class=annottext>{VV : [Char] | false}</span><span class='hs-varid'>str</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x_360 : [{lq_tmp_x_357 : Char^"lq_tmp_x_337" | $k__336[VV#335:=lq_tmp_x_357][lq_tmp_x_333:=lq_anf__d10I][lq_tmp_x_334:=str#aXp][lq_tmp_x_338:=lq_tmp_x_357][lq_tmp_x_330:=lq_tmp_x_360]}] | lq_tmp_x_360 == lq_anf__d10J}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x_342 : [Char] | lq_tmp_x_342 == lq_anf__d10I}</span><span class='hs-str'>"Oops, you didn't fill in the code for: "</span></a><span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x_346 : [Char] | lq_tmp_x_346 == str#aXp}</span><span class='hs-varid'>str</span></a><span class='hs-layout'>)</span>
</pre>
<h2 id="assertions-1">Assertions</h2>
<p>Lets define a refined type for the <code>Bool</code> that is <em>always</em> true:</p>
<pre><span class=hs-linenum>44: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>TRUE</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Prop</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Notice that we can now assign the type <code>TRUE</code> to any <code>Bool</code> expression that is guaranteed to evaluate to <code>True</code>:</p>
<pre><span class=hs-linenum>51: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>one_plus_one_eq_two</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TRUE</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>52: </span><a class=annot href="#"><span class=annottext>{v : Bool | Prop v}</span><span class='hs-definition'>one_plus_one_eq_two</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{lq_tmp_x_290 : Integer | lq_tmp_x_290 == lq_anf__d10D}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_284:Integer -&gt; lq_tmp_x_285:Integer -&gt; {lq_tmp_x_287 : Integer^"lq_tmp_x_286" | lq_tmp_x_287 == lq_tmp_x_284 + lq_tmp_x_285}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_291 : Integer | lq_tmp_x_291 == lq_anf__d10E}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_301:{lq_tmp_x_306 : Integer^"lq_tmp_x_305" | $k__304[VV#303:=lq_tmp_x_306][lq_tmp_x_300:=fix#GHC.Integer.Type.#36#fEqInteger#35#rIT]} -&gt; lq_tmp_x_302:{lq_tmp_x_306 : Integer^"lq_tmp_x_305" | $k__304[VV#303:=lq_tmp_x_306][lq_tmp_x_300:=fix#GHC.Integer.Type.#36#fEqInteger#35#rIT]} -&gt; {lq_tmp_x_296 : Bool | Prop lq_tmp_x_296 &lt;=&gt; lq_tmp_x_301 == lq_tmp_x_302}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_310 : Integer | lq_tmp_x_310 == lq_anf__d10G}</span><span class='hs-num'>2</span></a><span class='hs-layout'>)</span>
</pre>
<p>But of course, not to expressions that are <code>False</code>:</p>
<pre><span class=hs-linenum>58: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>one_plus_one_eq_three</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TRUE</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>59: </span><a class=annot href="#"><span class=annottext>{v : Bool | Prop v}</span><span class='hs-definition'>one_plus_one_eq_three</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{lq_tmp_x_253 : Integer | lq_tmp_x_253 == lq_anf__d10z}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_247:Integer -&gt; lq_tmp_x_248:Integer -&gt; {lq_tmp_x_250 : Integer^"lq_tmp_x_249" | lq_tmp_x_250 == lq_tmp_x_247 + lq_tmp_x_248}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_254 : Integer | lq_tmp_x_254 == lq_anf__d10A}</span><span class='hs-num'>2</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_264:{lq_tmp_x_269 : Integer^"lq_tmp_x_268" | $k__267[VV#266:=lq_tmp_x_269][lq_tmp_x_263:=fix#GHC.Integer.Type.#36#fEqInteger#35#rIT]} -&gt; lq_tmp_x_265:{lq_tmp_x_269 : Integer^"lq_tmp_x_268" | $k__267[VV#266:=lq_tmp_x_269][lq_tmp_x_263:=fix#GHC.Integer.Type.#36#fEqInteger#35#rIT]} -&gt; {lq_tmp_x_259 : Bool | Prop lq_tmp_x_259 &lt;=&gt; lq_tmp_x_264 == lq_tmp_x_265}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_273 : Integer | lq_tmp_x_273 == lq_anf__d10C}</span><span class='hs-num'>3</span></a><span class='hs-layout'>)</span>  <span class='hs-comment'>-- TYPE ERROR</span>
</pre>
<p>We can now use <code>TRUE</code> to define a <code>lAssert</code> function:</p>
<pre><span class=hs-linenum>65: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lAssert</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TRUE</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TRUE</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>66: </span><a class=annot href="#"><span class=annottext>lq_tmp_x_412:{v : Bool | Prop v} -&gt; {v : Bool | Prop v}</span><span class='hs-definition'>lAssert</span></a> <span class='hs-conid'>True</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x_451 : Bool | lq_tmp_x_451 == GHC.Types.True#6u}</span><span class='hs-conid'>True</span></a>
<span class=hs-linenum>67: </span><span class='hs-definition'>lAssert</span> <span class='hs-conid'>False</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x_437:{lq_tmp_x_435 : [Char] | false} -&gt; t</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_445 : [Char] | lq_tmp_x_445 == lq_anf__d10P}</span><span class='hs-str'>"Assert Fails!"</span></a>
</pre>
<p>Now, we can call <code>lAssert</code> only on expressions that we want to prove always hold, for example:</p>
<pre><span class=hs-linenum>74: </span><a class=annot href="#"><span class=annottext>{VV#453 : Bool^"lq_tmp_x_455" | $k__454}</span><span class='hs-definition'>propOk</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x_496:{lq_tmp_x_493 : Bool | Prop lq_tmp_x_493} -&gt; {lq_tmp_x_494 : Bool | Prop lq_tmp_x_494}</span><span class='hs-varid'>lAssert</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_497 : Bool | lq_tmp_x_497 == lq_anf__d10U}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x_471 : Integer | lq_tmp_x_471 == lq_anf__d10Q}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_465:Integer -&gt; lq_tmp_x_466:Integer -&gt; {lq_tmp_x_468 : Integer^"lq_tmp_x_467" | lq_tmp_x_468 == lq_tmp_x_465 + lq_tmp_x_466}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_472 : Integer | lq_tmp_x_472 == lq_anf__d10R}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_482:{lq_tmp_x_487 : Integer^"lq_tmp_x_486" | $k__485[VV#484:=lq_tmp_x_487][lq_tmp_x_481:=fix#GHC.Integer.Type.#36#fEqInteger#35#rIT]} -&gt; lq_tmp_x_483:{lq_tmp_x_487 : Integer^"lq_tmp_x_486" | $k__485[VV#484:=lq_tmp_x_487][lq_tmp_x_481:=fix#GHC.Integer.Type.#36#fEqInteger#35#rIT]} -&gt; {lq_tmp_x_477 : Bool | Prop lq_tmp_x_477 &lt;=&gt; lq_tmp_x_482 == lq_tmp_x_483}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_491 : Integer | lq_tmp_x_491 == lq_anf__d10T}</span><span class='hs-num'>2</span></a><span class='hs-layout'>)</span>
</pre>
<p>But if we try to <code>lAssert</code> bogus facts then they are rejected:</p>
<pre><span class=hs-linenum>80: </span><a class=annot href="#"><span class=annottext>{VV#499 : Bool^"lq_tmp_x_501" | $k__500}</span><span class='hs-definition'>propFail</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x_542:{lq_tmp_x_539 : Bool | Prop lq_tmp_x_539} -&gt; {lq_tmp_x_540 : Bool | Prop lq_tmp_x_540}</span><span class='hs-varid'>lAssert</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_543 : Bool | lq_tmp_x_543 == lq_anf__d10Z}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp_x_517 : Integer | lq_tmp_x_517 == lq_anf__d10V}</span><span class='hs-num'>2</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_511:Integer -&gt; lq_tmp_x_512:Integer -&gt; {lq_tmp_x_514 : Integer^"lq_tmp_x_513" | lq_tmp_x_514 == lq_tmp_x_511 + lq_tmp_x_512}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_518 : Integer | lq_tmp_x_518 == lq_anf__d10W}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_528:{lq_tmp_x_533 : Integer^"lq_tmp_x_532" | $k__531[VV#530:=lq_tmp_x_533][lq_tmp_x_527:=fix#GHC.Integer.Type.#36#fEqInteger#35#rIT]} -&gt; lq_tmp_x_529:{lq_tmp_x_533 : Integer^"lq_tmp_x_532" | $k__531[VV#530:=lq_tmp_x_533][lq_tmp_x_527:=fix#GHC.Integer.Type.#36#fEqInteger#35#rIT]} -&gt; {lq_tmp_x_523 : Bool | Prop lq_tmp_x_523 &lt;=&gt; lq_tmp_x_528 == lq_tmp_x_529}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_537 : Integer | lq_tmp_x_537 == lq_anf__d10Y}</span><span class='hs-num'>3</span></a><span class='hs-layout'>)</span> <span class='hs-comment'>-- TYPE ERROR</span>
</pre>
<h2 id="divide-by-zero">Divide By Zero</h2>
<p>Finally, lets write a <em>safe</em> divide by zero operator (that we will use later)</p>
<pre><span class=hs-linenum>89: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>divide</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| v /= 0}</span><span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Double</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>90: </span><a class=annot href="#"><span class=annottext>lq_tmp_x_545:Double -&gt; lq_tmp_x_546:{v : Int | v /= 0} -&gt; Double</span><span class='hs-definition'>divide</span></a> <a class=annot href="#"><span class=annottext>Double</span><span class='hs-varid'>n</span></a> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp_x_623:{lq_tmp_x_621 : [Char] | false} -&gt; t</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_631 : [Char] | lq_tmp_x_631 == lq_anf__d114}</span><span class='hs-str'>"oops divide by zero"</span></a>
<span class=hs-linenum>91: </span><span class='hs-definition'>divide</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp_x_602 : Double | lq_tmp_x_602 == n#aXq}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>lq_tmp_x_596:Double -&gt; lq_tmp_x_597:{lq_tmp_x_599 : Double^"lq_tmp_x_598" | lq_tmp_x_599 /= 0} -&gt; {lq_tmp_x_599 : Double^"lq_tmp_x_598" | lq_tmp_x_599 == lq_tmp_x_596 / lq_tmp_x_597}</span><span class='hs-varop'>/</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_603 : Double^"lq_tmp_x_583" | lq_tmp_x_603 == lq_anf__d112}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>lq_tmp_x_580:Int -&gt; {lq_tmp_x_584 : Double^"lq_tmp_x_583" | lq_tmp_x_584 == lq_tmp_x_580}</span><span class='hs-varid'>fromIntegral</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp_x_589 : Int | lq_tmp_x_589 == ds_d10v}</span><span class='hs-varid'>d</span></a><span class='hs-layout'>)</span>
</pre>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>
